# pr-service

Сервис для управления командами разработчиков и назначением ревьюверов на pull request'ы:

- создание команды и пользователей;
- включение/отключение пользователей (`is_active`);
- автоматическое назначение до 2 ревьюверов на PR из команды автора;
- перенос ревьювера на другого активного участника команды;
- массовая деактивация пользователей с перераспределением открытых PR;
- статистика по количеству назначений ревьюверов.

API описано в `openapi.yml`.

---

## Требования

Для разработки и запуска понадобятся:

- **Go** ≥ 1.21 (локальная сборка/тесты);
- **Docker** и **docker-compose** (рекомендованный способ запуска);
- **golangci-lint** (для `make lint`);
- **k6** (для нагрузочного теста, опционально).

---

## Быстрый старт (рекомендовано: всё в Docker)

1. **Собрать и поднять стенд** (Postgres + миграции + сервис):

   ```bash
   make run
   # эквивалентно:
   # docker-compose up --build

# Нагрузочное тестирование pr-service

## Цель

Проверить стабильность и производительность сервиса `pr-service` под одновременной нагрузкой при создании pull request'ов, а также убедиться в корректной обработке сценариев создания и конфликтов по `pull_request_id`.

## Тестовое окружение

- Инструмент нагрузки: **k6**
- Команда запуска:

```bash
k6 run -e BASE_URL=http://localhost:8080 loadtest/k6_pr_service.js
```

- Сценарий:
  - 50 виртуальных пользователей (VUs)
  - Продолжительность: 30 секунд
  - endpoint: `POST /pullRequest/create`
  - Тело запроса:

```json
{
  "pull_request_id": "k6-pr-<VU>-<ITER>",
  "pull_request_name": "Load test PR",
  "author_id": "u001"
}
```

## Конфигурация сценария k6

```js
export const options = {
    vus: 50,
    duration: '30s',
};

const BASE_URL = __ENV.BASE_URL || 'http://localhost:8080';

export default function () {
    const prID = `k6-pr-${__VU}-${__ITER}`;

    const payload = JSON.stringify({
        pull_request_id: prID,
        pull_request_name: 'Load test PR',
        author_id: 'u001',
    });

    const res = http.post(`${BASE_URL}/pullRequest/create`, payload, {
        headers: { 'Content-Type': 'application/json' },
    });

    check(res, {
        'status is 201 or 409': (r) => r.status === 201 || r.status === 409,
    });

    sleep(0.1);
}
```

## Сводка результатов

**Общая статистика:**

- Всего запросов: **14 472**
- Время выполнения сценария: **~30 секунд**
- Средний RPS (requests per second): **~480 req/s**
- Ошибки HTTP: **0%**
  - `checks_total`: 14 472
  - `checks_succeeded`: 100% (14 472 / 14 472)
  - `checks_failed`: 0%

**Проверки:**

- Условие: `status is 201 or 409`
  - Все запросы вернули либо **201 Created**, либо **409 Conflict**.
  - `409 Conflict` соответствует уже существующему `pull_request_id` (корректная бизнес-логика при коллизиях ID).

## Метрики HTTP

- `http_req_duration` (время обработки HTTP-запроса на сервере):
  - Среднее: **3.14 ms**
  - Минимум: **1.29 ms**
  - Медиана: **2.56 ms**
  - 90-й перцентиль (p90): **4.26 ms**
  - 95-й перцентиль (p95): **5.44 ms**
  - Максимум: **51.45 ms**

- `http_req_failed`: **0.00%** (0 из 14 472)

- `iteration_duration` (включая `sleep(0.1)` в сценарии k6):
  - Среднее: **103.82 ms**
  - Медиана: **103.2 ms**
  - p90: **105.12 ms**
  - p95: **106.45 ms**

## Нагрузка

- Виртуальные пользователи (VUs): **50**
- Диапазон VUs: от 50 до 50 (постоянная нагрузка)
- Полностью завершённых итераций: **14 472**
- Прерываний итераций: **0**

## Сетевые показатели

- Входящий трафик: **4.6 MB** (~153 kB/s)
- Исходящий трафик: **3.3 MB** (~110 kB/s)

## Выводы

1. Сервис `pr-service` стабильно выдерживает нагрузку **≈480 запросов в секунду** на ручку `POST /pullRequest/create` при 50 одновременных виртуальных пользователях.
2. **Ошибок HTTP (5xx/4xx, не предусмотренных бизнес-логикой) не зафиксировано**: показатель `http_req_failed` равен **0%**.
3. Все проверки k6 прошли успешно: на каждый запрос возвращался код **201** или **409**, что соответствует ожидаемому поведению сервиса:
   - **201 Created** — pull request успешно создан.
   - **409 Conflict** — pull request с таким `pull_request_id` уже существует (корректная обработка уникального ограничения).
4. Задержки на уровне сервера находятся в комфортных пределах:
   - среднее время ответа ~**3 ms**, p95 < **6 ms**, что укладывается в типичные SLA для внутренних сервисов.

**Итог:** сервис прошёл нагрузочное тестирование, повёл себя предсказуемо под нагрузкой и корректно обработал как успешные создания PR, так и конфликты по ID. Полученных результатов достаточно для прикладывания краткого отчёта к решению тестового задания.
